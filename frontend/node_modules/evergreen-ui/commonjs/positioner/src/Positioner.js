"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _Transition = _interopRequireDefault(require("react-transition-group/Transition"));

var _portal = require("../../portal");

var _stack = require("../../stack");

var _constants = require("../../constants");

var _getPosition2 = _interopRequireDefault(require("./getPosition"));

var animationEasing = {
  spring: "cubic-bezier(0.175, 0.885, 0.320, 1.175)"
};

var initialState = function initialState() {
  return {
    top: null,
    left: null,
    transformOrigin: null
  };
};

var getCSS = function getCSS(_ref) {
  var initialScale = _ref.initialScale,
      animationDuration = _ref.animationDuration;
  return {
    position: 'fixed',
    opacity: 0,
    transitionTimingFunction: animationEasing.spring,
    transitionDuration: "".concat(animationDuration, "ms"),
    transitionProperty: 'opacity, transform',
    transform: "scale(".concat(initialScale, ") translateY(-1px)"),
    '&[data-state="entering"], &[data-state="entered"]': {
      opacity: 1,
      visibility: 'visible',
      transform: "scale(1)"
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1)'
    }
  };
};

var Positioner =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(Positioner, _PureComponent);

  function Positioner(props, context) {
    var _this;

    (0, _classCallCheck2.default)(this, Positioner);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Positioner).call(this, props, context));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getTargetRef", function (ref) {
      _this.targetRef = ref;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getRef", function (ref) {
      _this.positionerRef = ref;

      _this.props.innerRef(ref);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleEnter", function () {
      _this.update();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "update", function () {
      var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!_this.props.isShown || !_this.targetRef || !_this.positionerRef) return;

      var targetRect = _this.targetRef.getBoundingClientRect();

      var hasEntered = _this.positionerRef.getAttribute('data-state') === 'entered';
      var viewportHeight = document.documentElement.clientHeight + window.scrollY;
      var viewportWidth = document.documentElement.clientWidth + window.scrollX;
      var height;
      var width;

      if (hasEntered) {
        // Only when the animation is done should we opt-in to `getBoundingClientRect`
        var positionerRect = _this.positionerRef.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255
        // We need to ceil the width and height to prevent jitter when
        // the window is zoomed (when `window.devicePixelRatio` is not an integer)


        height = Math.round(positionerRect.height);
        width = Math.round(positionerRect.width);
      } else {
        // When the animation is in flight use `offsetWidth/Height` which
        // does not calculate the `transform` property as part of its result.
        // There is still change on jitter during the animation (although unoticable)
        // When the browser is zoomed in â€” we fix this with `Math.max`.
        height = Math.max(_this.positionerRef.offsetHeight, prevHeight);
        width = Math.max(_this.positionerRef.offsetWidth, prevWidth);
      }

      var _getPosition = (0, _getPosition2.default)({
        position: _this.props.position,
        targetRect: targetRect,
        targetOffset: _this.props.targetOffset,
        dimensions: {
          height: height,
          width: width
        },
        viewport: {
          width: viewportWidth,
          height: viewportHeight
        },
        viewportOffset: _this.props.bodyOffset
      }),
          rect = _getPosition.rect,
          transformOrigin = _getPosition.transformOrigin;

      _this.setState({
        left: rect.left,
        top: rect.top,
        transformOrigin: transformOrigin
      }, function () {
        _this.latestAnimationFrame = requestAnimationFrame(function () {
          _this.update(height, width);
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleExited", function () {
      _this.setState(function () {
        return (0, _objectSpread2.default)({}, initialState());
      }, function () {
        _this.props.onCloseComplete();
      });
    });
    _this.state = initialState();
    return _this;
  }

  (0, _createClass2.default)(Positioner, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.latestAnimationFrame) {
        cancelAnimationFrame(this.latestAnimationFrame);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          target = _this$props.target,
          isShown = _this$props.isShown,
          children = _this$props.children,
          initialScale = _this$props.initialScale,
          targetOffset = _this$props.targetOffset,
          animationDuration = _this$props.animationDuration;
      var _this$state = this.state,
          left = _this$state.left,
          top = _this$state.top,
          transformOrigin = _this$state.transformOrigin;
      return _react.default.createElement(_stack.Stack, {
        value: _constants.StackingOrder.POSITIONER
      }, function (zIndex) {
        return _react.default.createElement(_react.default.Fragment, null, target({
          getRef: _this2.getTargetRef,
          isShown: isShown
        }), _react.default.createElement(_Transition.default, {
          in: isShown,
          timeout: animationDuration,
          onEnter: _this2.handleEnter,
          onEntered: _this2.props.onOpenComplete,
          onExited: _this2.handleExited,
          unmountOnExit: true
        }, function (state) {
          return _react.default.createElement(_portal.Portal, null, children({
            top: top,
            left: left,
            state: state,
            zIndex: zIndex,
            css: getCSS({
              targetOffset: targetOffset,
              initialScale: initialScale,
              animationDuration: animationDuration
            }),
            style: {
              transformOrigin: transformOrigin,
              left: left,
              top: top,
              zIndex: zIndex
            },
            getRef: _this2.getRef,
            animationDuration: animationDuration
          }));
        }));
      });
    }
  }]);
  return Positioner;
}(_react.PureComponent);

exports.default = Positioner;
Positioner.displayName = "Positioner";
(0, _defineProperty2.default)(Positioner, "propTypes", {
  /**
   * The position the element that is being positioned is on.
   * Smart positioning might override this.
   */
  position: _propTypes.default.oneOf([_constants.Position.TOP, _constants.Position.TOP_LEFT, _constants.Position.TOP_RIGHT, _constants.Position.BOTTOM, _constants.Position.BOTTOM_LEFT, _constants.Position.BOTTOM_RIGHT, _constants.Position.LEFT, _constants.Position.RIGHT]).isRequired,

  /**
   * When true, show the element being positioned.
   */
  isShown: _propTypes.default.bool,

  /**
   * Function that returns the element being positioned.
   */
  children: _propTypes.default.func.isRequired,

  /**
   * Function that returns the ref of the element being positioned.
   */
  innerRef: _propTypes.default.func.isRequired,

  /**
   * The minimum distance from the body to the element being positioned.
   */
  bodyOffset: _propTypes.default.number.isRequired,

  /**
   * The minimum distance from the target to the element being positioned.
   */
  targetOffset: _propTypes.default.number.isRequired,

  /**
   * Function that should return a node for the target.
   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node
   */
  target: _propTypes.default.func.isRequired,

  /**
   * Initial scale of the element being positioned.
   */
  initialScale: _propTypes.default.number.isRequired,

  /**
   * Duration of the animation.
   */
  animationDuration: _propTypes.default.number.isRequired,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: _propTypes.default.func.isRequired,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: _propTypes.default.func.isRequired
});
(0, _defineProperty2.default)(Positioner, "defaultProps", {
  position: _constants.Position.BOTTOM,
  bodyOffset: 6,
  targetOffset: 6,
  initialScale: 0.9,
  animationDuration: 300,
  innerRef: function innerRef() {},
  onOpenComplete: function onOpenComplete() {},
  onCloseComplete: function onCloseComplete() {}
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbImFuaW1hdGlvbkVhc2luZyIsInNwcmluZyIsImluaXRpYWxTdGF0ZSIsInRvcCIsImxlZnQiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJnZXRDU1MiLCJpbml0aWFsU2NhbGUiLCJhbmltYXRpb25EdXJhdGlvbiIsInBvc2l0aW9uIiwib3BhY2l0eSIsInRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zZm9ybSIsInZpc2liaWxpdHkiLCJQb3NpdGlvbmVyIiwicHJvcHMiLCJjb250ZXh0IiwicmVmIiwidGFyZ2V0UmVmIiwicG9zaXRpb25lclJlZiIsImlubmVyUmVmIiwidXBkYXRlIiwicHJldkhlaWdodCIsInByZXZXaWR0aCIsImlzU2hvd24iLCJ0YXJnZXRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFzRW50ZXJlZCIsImdldEF0dHJpYnV0ZSIsInZpZXdwb3J0SGVpZ2h0IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRIZWlnaHQiLCJ3aW5kb3ciLCJzY3JvbGxZIiwidmlld3BvcnRXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsImhlaWdodCIsIndpZHRoIiwicG9zaXRpb25lclJlY3QiLCJNYXRoIiwicm91bmQiLCJtYXgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInRhcmdldE9mZnNldCIsImRpbWVuc2lvbnMiLCJ2aWV3cG9ydCIsInZpZXdwb3J0T2Zmc2V0IiwiYm9keU9mZnNldCIsInJlY3QiLCJzZXRTdGF0ZSIsImxhdGVzdEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25DbG9zZUNvbXBsZXRlIiwic3RhdGUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRhcmdldCIsImNoaWxkcmVuIiwiU3RhY2tpbmdPcmRlciIsIlBPU0lUSU9ORVIiLCJ6SW5kZXgiLCJnZXRSZWYiLCJnZXRUYXJnZXRSZWYiLCJoYW5kbGVFbnRlciIsIm9uT3BlbkNvbXBsZXRlIiwiaGFuZGxlRXhpdGVkIiwiY3NzIiwic3R5bGUiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwib25lT2YiLCJQb3NpdGlvbiIsIlRPUCIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJMRUZUIiwiUklHSFQiLCJpc1JlcXVpcmVkIiwiYm9vbCIsImZ1bmMiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLElBQU1BLGVBQWUsR0FBRztBQUN0QkMsRUFBQUEsTUFBTTtBQURnQixDQUF4Qjs7QUFJQSxJQUFNQyxZQUFZLEdBQUcsU0FBZkEsWUFBZTtBQUFBLFNBQU87QUFDMUJDLElBQUFBLEdBQUcsRUFBRSxJQURxQjtBQUUxQkMsSUFBQUEsSUFBSSxFQUFFLElBRm9CO0FBRzFCQyxJQUFBQSxlQUFlLEVBQUU7QUFIUyxHQUFQO0FBQUEsQ0FBckI7O0FBTUEsSUFBTUMsTUFBTSxHQUFHLFNBQVRBLE1BQVM7QUFBQSxNQUFHQyxZQUFILFFBQUdBLFlBQUg7QUFBQSxNQUFpQkMsaUJBQWpCLFFBQWlCQSxpQkFBakI7QUFBQSxTQUEwQztBQUN2REMsSUFBQUEsUUFBUSxFQUFFLE9BRDZDO0FBRXZEQyxJQUFBQSxPQUFPLEVBQUUsQ0FGOEM7QUFHdkRDLElBQUFBLHdCQUF3QixFQUFFWCxlQUFlLENBQUNDLE1BSGE7QUFJdkRXLElBQUFBLGtCQUFrQixZQUFLSixpQkFBTCxPQUpxQztBQUt2REssSUFBQUEsa0JBQWtCLEVBQUUsb0JBTG1DO0FBTXZEQyxJQUFBQSxTQUFTLGtCQUFXUCxZQUFYLHVCQU44QztBQU92RCx5REFBcUQ7QUFDbkRHLE1B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LElBQVYsQ0FBZUYsVUE1RGY7O0FBOERqQjs7O0FBR0FoQixFQUFBQSxjQUFjLEVBQUVLLG1CQUFVYSxJQUFWLENBQWVGO0FBakVkLEM7OEJBREFwRSxVLGtCQXFFRztBQUNwQlAsRUFBQUEsUUFBUSxFQUFFa0Usb0JBQVNJLE1BREM7QUFFcEIzQixFQUFBQSxVQUFVLEVBQUUsQ0FGUTtBQUdwQkosRUFBQUEsWUFBWSxFQUFFLENBSE07QUFJcEJ6QyxFQUFBQSxZQUFZLEVBQUUsR0FKTTtBQUtwQkMsRUFBQUEsaUJBQWlCLEVBQUUsR0FMQztBQU1wQmMsRUFBQUEsUUFBUSxFQUFFLG9CQUFNLENBQUUsQ0FORTtBQU9wQjhDLEVBQUFBLGNBQWMsRUFBRSwwQkFBTSxDQUFFLENBUEo7QUFRcEJYLEVBQUFBLGVBQWUsRUFBRSwyQkFBTSxDQUFFO0FBUkwsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwL1RyYW5zaXRpb24nXG5pbXBvcnQgeyBQb3J0YWwgfSBmcm9tICcuLi8uLi9wb3J0YWwnXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJy4uLy4uL3N0YWNrJ1xuaW1wb3J0IHsgU3RhY2tpbmdPcmRlciwgUG9zaXRpb24gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnXG5pbXBvcnQgZ2V0UG9zaXRpb24gZnJvbSAnLi9nZXRQb3NpdGlvbidcblxuY29uc3QgYW5pbWF0aW9uRWFzaW5nID0ge1xuICBzcHJpbmc6IGBjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyMCwgMS4xNzUpYFxufVxuXG5jb25zdCBpbml0aWFsU3RhdGUgPSAoKSA9PiAoe1xuICB0b3A6IG51bGwsXG4gIGxlZnQ6IG51bGwsXG4gIHRyYW5zZm9ybU9yaWdpbjogbnVsbFxufSlcblxuY29uc3QgZ2V0Q1NTID0gKHsgaW5pdGlhbFNjYWxlLCBhbmltYXRpb25EdXJhdGlvbiB9KSA9PiAoe1xuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgb3BhY2l0eTogMCxcbiAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBhbmltYXRpb25FYXNpbmcuc3ByaW5nLFxuICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2FuaW1hdGlvbkR1cmF0aW9ufW1zYCxcbiAgdHJhbnNpdGlvblByb3BlcnR5OiAnb3BhY2l0eSwgdHJhbnNmb3JtJyxcbiAgdHJhbnNmb3JtOiBgc2NhbGUoJHtpbml0aWFsU2NhbGV9KSB0cmFuc2xhdGVZKC0xcHgpYCxcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdLCAmW2RhdGEtc3RhdGU9XCJlbnRlcmVkXCJdJzoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuICAgIHRyYW5zZm9ybTogYHNjYWxlKDEpYFxuICB9LFxuICAnJltkYXRhLXN0YXRlPVwiZXhpdGluZ1wiXSc6IHtcbiAgICBvcGFjaXR5OiAwLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbmVyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcG9zaXRpb25lZCBpcyBvbi5cbiAgICAgKiBTbWFydCBwb3NpdGlvbmluZyBtaWdodCBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIHBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICAgUG9zaXRpb24uVE9QLFxuICAgICAgUG9zaXRpb24uVE9QX0xFRlQsXG4gICAgICBQb3NpdGlvbi5UT1BfUklHSFQsXG4gICAgICBQb3NpdGlvbi5CT1RUT00sXG4gICAgICBQb3NpdGlvbi5CT1RUT01fTEVGVCxcbiAgICAgIFBvc2l0aW9uLkJPVFRPTV9SSUdIVCxcbiAgICAgIFBvc2l0aW9uLkxFRlQsXG4gICAgICBQb3NpdGlvbi5SSUdIVFxuICAgIF0pLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHNob3cgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICAgKi9cbiAgICBpc1Nob3duOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZWYgb2YgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICAgKi9cbiAgICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGZyb20gdGhlIGJvZHkgdG8gdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICAgKi9cbiAgICBib2R5T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICAgKi9cbiAgICB0YXJnZXRPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiBhIG5vZGUgZm9yIHRoZSB0YXJnZXQuXG4gICAgICogKHsgZ2V0UmVmOiAoKSAtPiBSZWYsIGlzU2hvd246IEJvb2wgfSkgLT4gUmVhY3QgTm9kZVxuICAgICAqL1xuICAgIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWwgc2NhbGUgb2YgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICAgKi9cbiAgICBpbml0aWFsU2NhbGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZXhpdCB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIG9uQ2xvc2VDb21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZW50ZXIgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBvbk9wZW5Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBwb3NpdGlvbjogUG9zaXRpb24uQk9UVE9NLFxuICAgIGJvZHlPZmZzZXQ6IDYsXG4gICAgdGFyZ2V0T2Zmc2V0OiA2LFxuICAgIGluaXRpYWxTY2FsZTogMC45LFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAzMDAsXG4gICAgaW5uZXJSZWY6ICgpID0+IHt9LFxuICAgIG9uT3BlbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICBvbkNsb3NlQ29tcGxldGU6ICgpID0+IHt9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KVxuICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGUoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMubGF0ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF0ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgfVxuICB9XG5cbiAgZ2V0VGFyZ2V0UmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnRhcmdldFJlZiA9IHJlZlxuICB9XG5cbiAgZ2V0UmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnBvc2l0aW9uZXJSZWYgPSByZWZcbiAgICB0aGlzLnByb3BzLmlubmVyUmVmKHJlZilcbiAgfVxuXG4gIGhhbmRsZUVudGVyID0gKCkgPT4ge1xuICAgIHRoaXMudXBkYXRlKClcbiAgfVxuXG4gIHVwZGF0ZSA9IChwcmV2SGVpZ2h0ID0gMCwgcHJldldpZHRoID0gMCkgPT4ge1xuICAgIGlmICghdGhpcy5wcm9wcy5pc1Nob3duIHx8ICF0aGlzLnRhcmdldFJlZiB8fCAhdGhpcy5wb3NpdGlvbmVyUmVmKSByZXR1cm5cblxuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0aGlzLnRhcmdldFJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IGhhc0VudGVyZWQgPVxuICAgICAgdGhpcy5wb3NpdGlvbmVyUmVmLmdldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScpID09PSAnZW50ZXJlZCdcblxuICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID1cbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyB3aW5kb3cuc2Nyb2xsWVxuICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyB3aW5kb3cuc2Nyb2xsWFxuXG4gICAgbGV0IGhlaWdodFxuICAgIGxldCB3aWR0aFxuICAgIGlmIChoYXNFbnRlcmVkKSB7XG4gICAgICAvLyBPbmx5IHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBkb25lIHNob3VsZCB3ZSBvcHQtaW4gdG8gYGdldEJvdW5kaW5nQ2xpZW50UmVjdGBcbiAgICAgIGNvbnN0IHBvc2l0aW9uZXJSZWN0ID0gdGhpcy5wb3NpdGlvbmVyUmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50aW8vZXZlcmdyZWVuL2lzc3Vlcy8yNTVcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2VpbCB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBwcmV2ZW50IGppdHRlciB3aGVuXG4gICAgICAvLyB0aGUgd2luZG93IGlzIHpvb21lZCAod2hlbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIGlzIG5vdCBhbiBpbnRlZ2VyKVxuICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChwb3NpdGlvbmVyUmVjdC5oZWlnaHQpXG4gICAgICB3aWR0aCA9IE1hdGgucm91bmQocG9zaXRpb25lclJlY3Qud2lkdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbiBmbGlnaHQgdXNlIGBvZmZzZXRXaWR0aC9IZWlnaHRgIHdoaWNoXG4gICAgICAvLyBkb2VzIG5vdCBjYWxjdWxhdGUgdGhlIGB0cmFuc2Zvcm1gIHByb3BlcnR5IGFzIHBhcnQgb2YgaXRzIHJlc3VsdC5cbiAgICAgIC8vIFRoZXJlIGlzIHN0aWxsIGNoYW5nZSBvbiBqaXR0ZXIgZHVyaW5nIHRoZSBhbmltYXRpb24gKGFsdGhvdWdoIHVub3RpY2FibGUpXG4gICAgICAvLyBXaGVuIHRoZSBicm93c2VyIGlzIHpvb21lZCBpbiDigJQgd2UgZml4IHRoaXMgd2l0aCBgTWF0aC5tYXhgLlxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5wb3NpdGlvbmVyUmVmLm9mZnNldEhlaWdodCwgcHJldkhlaWdodClcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgodGhpcy5wb3NpdGlvbmVyUmVmLm9mZnNldFdpZHRoLCBwcmV2V2lkdGgpXG4gICAgfVxuXG4gICAgY29uc3QgeyByZWN0LCB0cmFuc2Zvcm1PcmlnaW4gfSA9IGdldFBvc2l0aW9uKHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLnByb3BzLnBvc2l0aW9uLFxuICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgIHRhcmdldE9mZnNldDogdGhpcy5wcm9wcy50YXJnZXRPZmZzZXQsXG4gICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGhcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICB3aWR0aDogdmlld3BvcnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydEhlaWdodFxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0T2Zmc2V0OiB0aGlzLnByb3BzLmJvZHlPZmZzZXRcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW5cbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMubGF0ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMudXBkYXRlKGhlaWdodCwgd2lkdGgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgaGFuZGxlRXhpdGVkID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaW5pdGlhbFN0YXRlKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlQ29tcGxldGUoKVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBpc1Nob3duLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpbml0aWFsU2NhbGUsXG4gICAgICB0YXJnZXRPZmZzZXQsXG4gICAgICBhbmltYXRpb25EdXJhdGlvblxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB7IGxlZnQsIHRvcCwgdHJhbnNmb3JtT3JpZ2luIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN0YWNrIHZhbHVlPXtTdGFja2luZ09yZGVyLlBPU0lUSU9ORVJ9PlxuICAgICAgICB7ekluZGV4ID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICB7dGFyZ2V0KHsgZ2V0UmVmOiB0aGlzLmdldFRhcmdldFJlZiwgaXNTaG93biB9KX1cblxuICAgICAgICAgICAgICA8VHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIGluPXtpc1Nob3dufVxuICAgICAgICAgICAgICAgIHRpbWVvdXQ9e2FuaW1hdGlvbkR1cmF0aW9ufVxuICAgICAgICAgICAgICAgIG9uRW50ZXI9e3RoaXMuaGFuZGxlRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25FbnRlcmVkPXt0aGlzLnByb3BzLm9uT3BlbkNvbXBsZXRlfVxuICAgICAgICAgICAgICAgIG9uRXhpdGVkPXt0aGlzLmhhbmRsZUV4aXRlZH1cbiAgICAgICAgICAgICAgICB1bm1vdW50T25FeGl0XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7c3RhdGUgPT4gKFxuICAgICAgICAgICAgICAgICAgPFBvcnRhbD5cbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVuKHtcbiAgICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgY3NzOiBnZXRDU1Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0UmVmOiB0aGlzLmdldFJlZixcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgIDwvUG9ydGFsPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvVHJhbnNpdGlvbj5cbiAgICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9TdGFjaz5cbiAgICApXG4gIH1cbn1cbiJdfQ==