"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _toaster = require("../../toaster");

var _theme = require("../../theme");

var _layers = require("../../layers");

var _TableRowContext = require("./TableRowContext");

var _manageTableCellFocusInteraction = _interopRequireDefault(require("./manageTableCellFocusInteraction"));

var TableCell =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(TableCell, _PureComponent);

  function TableCell() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, TableCell);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TableCell)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleKeyDown", function (e) {
      if (_this.props.isSelectable) {
        var key = e.key;

        if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
          try {
            (0, _manageTableCellFocusInteraction.default)(key, _this.mainRef);
          } catch (error) {
            _toaster.toaster.danger('Keyboard interaction not possible');

            console.error('Keyboard control not impossible', error);
          }
        } else if (key === 'Escape') {
          _this.mainRef.blur();
        }
      }

      if (typeof _this.props.onKeyDown === 'function') {
        _this.props.onKeyDown(e);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRef", function (ref) {
      _this.mainRef = ref;

      if (typeof _this.props.innerRef === 'function') {
        _this.props.innerRef(ref);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleClick", function (e) {
      if (typeof _this.props.onClick === 'function') {
        _this.props.onClick(e);
      }
    });
    return _this;
  }

  (0, _createClass2.default)(TableCell, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          innerRef = _this$props.innerRef,
          theme = _this$props.theme,
          children = _this$props.children,
          appearance = _this$props.appearance,
          onClick = _this$props.onClick,
          onKeyPress = _this$props.onKeyPress,
          onKeyDown = _this$props.onKeyDown,
          isSelectable = _this$props.isSelectable,
          _this$props$tabIndex = _this$props.tabIndex,
          tabIndex = _this$props$tabIndex === void 0 ? -1 : _this$props$tabIndex,
          className = _this$props.className,
          rightView = _this$props.rightView,
          props = (0, _objectWithoutProperties2.default)(_this$props, ["innerRef", "theme", "children", "appearance", "onClick", "onKeyPress", "onKeyDown", "isSelectable", "tabIndex", "className", "rightView"]);
      var themedClassName = theme.getTableCellClassName(appearance);
      return _react.default.createElement(_TableRowContext.TableRowConsumer, null, function (height) {
        return _react.default.createElement(_layers.Pane, (0, _extends2.default)({
          innerRef: _this2.onRef,
          height: height,
          className: (0, _classnames.default)(themedClassName, className),
          tabIndex: isSelectable ? tabIndex : undefined,
          "data-isselectable": isSelectable,
          onClick: _this2.handleClick,
          onKeyDown: _this2.handleKeyDown
        }, TableCell.styles, props), children, rightView ? rightView : null);
      });
    }
  }]);
  return TableCell;
}(_react.PureComponent);

TableCell.displayName = "TableCell";
(0, _defineProperty2.default)(TableCell, "propTypes", (0, _objectSpread2.default)({}, _layers.Pane.propTypes, {
  /*
  * Makes the TableCell focusable. Used by EditableCell.
  * Will add tabIndex={-1 || this.props.tabIndex}.
  */
  isSelectable: _propTypes.default.bool,

  /**
   * The appearance of the table row. Default theme only support default.
   */
  appearance: _propTypes.default.string.isRequired,

  /**
   * Optional node to be placed on the right side of the table cell.
   * Useful for icons and icon buttons.
   */
  rightView: _propTypes.default.node,

  /**
   * Theme provided by ThemeProvider.
   */
  theme: _propTypes.default.object.isRequired,

  /**
   * Class name passed to the table cell.
   * Only use if you know what you are doing.
   */
  className: _propTypes.default.string
}));
(0, _defineProperty2.default)(TableCell, "defaultProps", {
  appearance: 'default'
});
(0, _defineProperty2.default)(TableCell, "styles", {
  paddingX: 12,
  boxSizing: 'border-box',
  flex: 1,
  display: 'flex',
  alignItems: 'center',
  flexShrink: 0,
  overflow: 'hidden'
});

var _default = (0, _theme.withTheme)(TableCell);

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVDZWxsLmpzIl0sIm5hbWVzIjpbIlRhYmxlQ2VsbCIsImUiLCJwcm9wcyIsImlzU2VsZWN0YWJsZSIsImtleSIsIm1haW5SZWYiLCJlcnJvciIsInRvYXN0ZXIiLCJkYW5nZXIiLCJjb25zb2xlIiwiYmx1ciIsIm9uS2V5RG93biIsInJlZiIsImlubmVyUmVmIiwib25DbGljayIsInRoZW1lIiwiY2hpbGRyZW4iLCJhcHBlYXJhbmNlIiwib25LZXlQcmVzcyIsInRhYkluZGV4IiwiY2xhc3NOYW1lIiwicmlnaHRWaWV3IiwidGhlbWVkQ2xhc3NOYW1lIiwiZ2V0VGFibGVDZWxsQ2xhc3NOYW1lIiwiaGVpZ2h0Iiwib25SZWYiLCJ1bmRlZmluZWQiLCJoYW5kbGVDbGljayIsImhhbmRsZUtleURvd24iLCJzdHlsZXMiLCJQdXJlQ29tcG9uZW50IiwiUGFuZSIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImJvb2wiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwibm9kZSIsIm9iamVjdCIsInBhZGRpbmdYIiwiYm94U2l6aW5nIiwiZmxleCIsImRpc3BsYXkiLCJhbGlnbkl0ZW1zIiwiZmxleFNocmluayIsIm92ZXJmbG93Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0lBRU1BLFM7Ozs7Ozs7Ozs7Ozs7Ozs7O3NJQWtEWSxVQUFBQyxDQUFDLEVBQUk7QUFDbkIsVUFBSSxNQUFLQyxLQUFMLENBQVdDLFlBQWYsRUFBNkI7QUFBQSxZQUNuQkMsR0FEbUIsR0FDWEgsQ0FEVyxDQUNuQkcsR0FEbUI7O0FBRTNCLFlBQ0VBLEdBQUcsS0FBSyxTQUFSLElBQ0FBLEdBQUcsS0FBSyxXQURSLElBRUFBLEdBQUcsS0FBSyxXQUZSLElBR0FBLEdBQUcsS0FBSyxZQUpWLEVBS0U7QUFDQSxjQUFJO0FBQ0Ys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b0NrQjtBQUNwQmlCLEVBQUFBLFVBQVUsRUFBRTtBQURRLEM7OEJBcENsQmpCLFMsWUF3Q1k7QUFDZHVDLEVBQUFBLFFBQVEsRUFBRSxFQURJO0FBRWRDLEVBQUFBLFNBQVMsRUFBRSxZQUZHO0FBR2RDLEVBQUFBLElBQUksRUFBRSxDQUhRO0FBSWRDLEVBQUFBLE9BQU8sRUFBRSxNQUpLO0FBS2RDLEVBQUFBLFVBQVUsRUFBRSxRQUxFO0FBTWRDLEVBQUFBLFVBQVUsRUFBRSxDQU5FO0FBT2RDLEVBQUFBLFFBQVEsRUFBRTtBQVBJLEM7O2VBNEZILHNCQUFVN0MsU0FBVixDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJ1xuaW1wb3J0IHsgdG9hc3RlciB9IGZyb20gJy4uLy4uL3RvYXN0ZXInXG5pbXBvcnQgeyB3aXRoVGhlbWUgfSBmcm9tICcuLi8uLi90aGVtZSdcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi8uLi9sYXllcnMnXG5pbXBvcnQgeyBUYWJsZVJvd0NvbnN1bWVyIH0gZnJvbSAnLi9UYWJsZVJvd0NvbnRleHQnXG5pbXBvcnQgbWFuYWdlVGFibGVDZWxsRm9jdXNJbnRlcmFjdGlvbiBmcm9tICcuL21hbmFnZVRhYmxlQ2VsbEZvY3VzSW50ZXJhY3Rpb24nXG5cbmNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBQYW5lIGNvbXBvbmVudCBhcyB0aGUgYmFzZS5cbiAgICAgKi9cbiAgICAuLi5QYW5lLnByb3BUeXBlcyxcblxuICAgIC8qXG4gICAgKiBNYWtlcyB0aGUgVGFibGVDZWxsIGZvY3VzYWJsZS4gVXNlZCBieSBFZGl0YWJsZUNlbGwuXG4gICAgKiBXaWxsIGFkZCB0YWJJbmRleD17LTEgfHwgdGhpcy5wcm9wcy50YWJJbmRleH0uXG4gICAgKi9cbiAgICBpc1NlbGVjdGFibGU6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRhYmxlIHJvdy4gRGVmYXVsdCB0aGVtZSBvbmx5IHN1cHBvcnQgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBhcHBlYXJhbmNlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBub2RlIHRvIGJlIHBsYWNlZCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdGFibGUgY2VsbC5cbiAgICAgKiBVc2VmdWwgZm9yIGljb25zIGFuZCBpY29uIGJ1dHRvbnMuXG4gICAgICovXG4gICAgcmlnaHRWaWV3OiBQcm9wVHlwZXMubm9kZSxcblxuICAgIC8qKlxuICAgICAqIFRoZW1lIHByb3ZpZGVkIGJ5IFRoZW1lUHJvdmlkZXIuXG4gICAgICovXG4gICAgdGhlbWU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIG5hbWUgcGFzc2VkIHRvIHRoZSB0YWJsZSBjZWxsLlxuICAgICAqIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgYXBwZWFyYW5jZTogJ2RlZmF1bHQnXG4gIH1cblxuICBzdGF0aWMgc3R5bGVzID0ge1xuICAgIHBhZGRpbmdYOiAxMixcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmbGV4OiAxLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBmbGV4U2hyaW5rOiAwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICB9XG5cbiAgaGFuZGxlS2V5RG93biA9IGUgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmlzU2VsZWN0YWJsZSkge1xuICAgICAgY29uc3QgeyBrZXkgfSA9IGVcbiAgICAgIGlmIChcbiAgICAgICAga2V5ID09PSAnQXJyb3dVcCcgfHxcbiAgICAgICAga2V5ID09PSAnQXJyb3dEb3duJyB8fFxuICAgICAgICBrZXkgPT09ICdBcnJvd0xlZnQnIHx8XG4gICAgICAgIGtleSA9PT0gJ0Fycm93UmlnaHQnXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYW5hZ2VUYWJsZUNlbGxGb2N1c0ludGVyYWN0aW9uKGtleSwgdGhpcy5tYWluUmVmKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRvYXN0ZXIuZGFuZ2VyKCdLZXlib2FyZCBpbnRlcmFjdGlvbiBub3QgcG9zc2libGUnKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0tleWJvYXJkIGNvbnRyb2wgbm90IGltcG9zc2libGUnLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIHRoaXMubWFpblJlZi5ibHVyKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25LZXlEb3duID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5RG93bihlKVxuICAgIH1cbiAgfVxuXG4gIG9uUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLm1haW5SZWYgPSByZWZcblxuICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5pbm5lclJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5wcm9wcy5pbm5lclJlZihyZWYpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xpY2sgPSBlID0+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKGUpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlubmVyUmVmLFxuICAgICAgdGhlbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFwcGVhcmFuY2UsXG4gICAgICBvbkNsaWNrLFxuICAgICAgb25LZXlQcmVzcyxcbiAgICAgIG9uS2V5RG93bixcbiAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgIHRhYkluZGV4ID0gLTEsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICByaWdodFZpZXcsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB0aGVtZWRDbGFzc05hbWUgPSB0aGVtZS5nZXRUYWJsZUNlbGxDbGFzc05hbWUoYXBwZWFyYW5jZSlcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGVSb3dDb25zdW1lcj5cbiAgICAgICAge2hlaWdodCA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgIGlubmVyUmVmPXt0aGlzLm9uUmVmfVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjeCh0aGVtZWRDbGFzc05hbWUsIGNsYXNzTmFtZSl9XG4gICAgICAgICAgICAgIHRhYkluZGV4PXtpc1NlbGVjdGFibGUgPyB0YWJJbmRleCA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgZGF0YS1pc3NlbGVjdGFibGU9e2lzU2VsZWN0YWJsZX1cbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgICAgIHsuLi5UYWJsZUNlbGwuc3R5bGVzfVxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAge3JpZ2h0VmlldyA/IHJpZ2h0VmlldyA6IG51bGx9XG4gICAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9UYWJsZVJvd0NvbnN1bWVyPlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoVGFibGVDZWxsKVxuIl19