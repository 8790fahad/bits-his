import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import Transition from 'react-transition-group/Transition';
import { Portal } from '../../portal';
import { Stack } from '../../stack';
import { StackingOrder, Position } from '../../constants';
import getPosition from './getPosition';
var animationEasing = {
  spring: "cubic-bezier(0.175, 0.885, 0.320, 1.175)"
};

var initialState = function initialState() {
  return {
    top: null,
    left: null,
    transformOrigin: null
  };
};

var getCSS = function getCSS(_ref) {
  var initialScale = _ref.initialScale,
      animationDuration = _ref.animationDuration;
  return {
    position: 'fixed',
    opacity: 0,
    transitionTimingFunction: animationEasing.spring,
    transitionDuration: "".concat(animationDuration, "ms"),
    transitionProperty: 'opacity, transform',
    transform: "scale(".concat(initialScale, ") translateY(-1px)"),
    '&[data-state="entering"], &[data-state="entered"]': {
      opacity: 1,
      visibility: 'visible',
      transform: "scale(1)"
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1)'
    }
  };
};

var Positioner =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(Positioner, _PureComponent);

  function Positioner(props, context) {
    var _this;

    _classCallCheck(this, Positioner);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Positioner).call(this, props, context));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getTargetRef", function (ref) {
      _this.targetRef = ref;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getRef", function (ref) {
      _this.positionerRef = ref;

      _this.props.innerRef(ref);
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleEnter", function () {
      _this.update();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "update", function () {
      var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!_this.props.isShown || !_this.targetRef || !_this.positionerRef) return;

      var targetRect = _this.targetRef.getBoundingClientRect();

      var hasEntered = _this.positionerRef.getAttribute('data-state') === 'entered';
      var viewportHeight = document.documentElement.clientHeight + window.scrollY;
      var viewportWidth = document.documentElement.clientWidth + window.scrollX;
      var height;
      var width;

      if (hasEntered) {
        // Only when the animation is done should we opt-in to `getBoundingClientRect`
        var positionerRect = _this.positionerRef.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255
        // We need to ceil the width and height to prevent jitter when
        // the window is zoomed (when `window.devicePixelRatio` is not an integer)


        height = Math.round(positionerRect.height);
        width = Math.round(positionerRect.width);
      } else {
        // When the animation is in flight use `offsetWidth/Height` which
        // does not calculate the `transform` property as part of its result.
        // There is still change on jitter during the animation (although unoticable)
        // When the browser is zoomed in â€” we fix this with `Math.max`.
        height = Math.max(_this.positionerRef.offsetHeight, prevHeight);
        width = Math.max(_this.positionerRef.offsetWidth, prevWidth);
      }

      var _getPosition = getPosition({
        position: _this.props.position,
        targetRect: targetRect,
        targetOffset: _this.props.targetOffset,
        dimensions: {
          height: height,
          width: width
        },
        viewport: {
          width: viewportWidth,
          height: viewportHeight
        },
        viewportOffset: _this.props.bodyOffset
      }),
          rect = _getPosition.rect,
          transformOrigin = _getPosition.transformOrigin;

      _this.setState({
        left: rect.left,
        top: rect.top,
        transformOrigin: transformOrigin
      }, function () {
        _this.latestAnimationFrame = requestAnimationFrame(function () {
          _this.update(height, width);
        });
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleExited", function () {
      _this.setState(function () {
        return _objectSpread({}, initialState());
      }, function () {
        _this.props.onCloseComplete();
      });
    });

    _this.state = initialState();
    return _this;
  }

  _createClass(Positioner, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.latestAnimationFrame) {
        cancelAnimationFrame(this.latestAnimationFrame);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          target = _this$props.target,
          isShown = _this$props.isShown,
          children = _this$props.children,
          initialScale = _this$props.initialScale,
          targetOffset = _this$props.targetOffset,
          animationDuration = _this$props.animationDuration;
      var _this$state = this.state,
          left = _this$state.left,
          top = _this$state.top,
          transformOrigin = _this$state.transformOrigin;
      return React.createElement(Stack, {
        value: StackingOrder.POSITIONER
      }, function (zIndex) {
        return React.createElement(React.Fragment, null, target({
          getRef: _this2.getTargetRef,
          isShown: isShown
        }), React.createElement(Transition, {
          in: isShown,
          timeout: animationDuration,
          onEnter: _this2.handleEnter,
          onEntered: _this2.props.onOpenComplete,
          onExited: _this2.handleExited,
          unmountOnExit: true
        }, function (state) {
          return React.createElement(Portal, null, children({
            top: top,
            left: left,
            state: state,
            zIndex: zIndex,
            css: getCSS({
              targetOffset: targetOffset,
              initialScale: initialScale,
              animationDuration: animationDuration
            }),
            style: {
              transformOrigin: transformOrigin,
              left: left,
              top: top,
              zIndex: zIndex
            },
            getRef: _this2.getRef,
            animationDuration: animationDuration
          }));
        }));
      });
    }
  }]);

  return Positioner;
}(PureComponent);

Positioner.displayName = "Positioner";

_defineProperty(Positioner, "propTypes", {
  /**
   * The position the element that is being positioned is on.
   * Smart positioning might override this.
   */
  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]).isRequired,

  /**
   * When true, show the element being positioned.
   */
  isShown: PropTypes.bool,

  /**
   * Function that returns the element being positioned.
   */
  children: PropTypes.func.isRequired,

  /**
   * Function that returns the ref of the element being positioned.
   */
  innerRef: PropTypes.func.isRequired,

  /**
   * The minimum distance from the body to the element being positioned.
   */
  bodyOffset: PropTypes.number.isRequired,

  /**
   * The minimum distance from the target to the element being positioned.
   */
  targetOffset: PropTypes.number.isRequired,

  /**
   * Function that should return a node for the target.
   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node
   */
  target: PropTypes.func.isRequired,

  /**
   * Initial scale of the element being positioned.
   */
  initialScale: PropTypes.number.isRequired,

  /**
   * Duration of the animation.
   */
  animationDuration: PropTypes.number.isRequired,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: PropTypes.func.isRequired,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: PropTypes.func.isRequired
});

_defineProperty(Positioner, "defaultProps", {
  position: Position.BOTTOM,
  bodyOffset: 6,
  targetOffset: 6,
  initialScale: 0.9,
  animationDuration: 300,
  innerRef: function innerRef() {},
  onOpenComplete: function onOpenComplete() {},
  onCloseComplete: function onCloseComplete() {}
});

export { Positioner as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsIlRyYW5zaXRpb24iLCJQb3J0YWwiLCJTdGFjayIsIlN0YWNraW5nT3JkZXIiLCJQb3NpdGlvbiIsImdldFBvc2l0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwic3ByaW5nIiwiaW5pdGlhbFN0YXRlIiwidG9wIiwibGVmdCIsInRyYW5zZm9ybU9yaWdpbiIsImdldENTUyIsImluaXRpYWxTY2FsZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwicG9zaXRpb24iLCJvcGFjaXR5IiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNmb3JtIiwidmlzaWJpbGl0eSIsIlBvc2l0aW9uZXIiLCJwcm9wcyIsImNvbnRleHQiLCJyZWYiLCJ0YXJnZXRSZWYiLCJwb3NpdGlvbmVyUmVmIiwiaW5uZXJSZWYiLCJ1cGRhdGUiLCJwcmV2SGVpZ2h0IiwicHJldldpZHRoIiwiaXNTaG93biIsInRhcmdldFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoYXNFbnRlcmVkIiwiZ2V0QXR0cmlidXRlIiwidmlld3BvcnRIZWlnaHQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsIndpbmRvdyIsInNjcm9sbFkiLCJ2aWV3cG9ydFdpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxYIiwiaGVpZ2h0Iiwid2lkdGgiLCJwb3NpdGlvbmVyUmVjdCIsIk1hdGgiLCJyb3VuZCIsIm1heCIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwidGFyZ2V0T2Zmc2V0IiwiZGltZW5zaW9ucyIsInZpZXdwb3J0Iiwidmlld3BvcnRPZmZzZXQiLCJib2R5T2Zmc2V0IiwicmVjdCIsInNldFN0YXRlIiwibGF0ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvbkNsb3NlQ29tcGxldGUiLCJzdGF0ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidGFyZ2V0IiwiY2hpbGRyZW4iLCJQT1NJVElPTkVSIiwiekluZGV4IiwiZ2V0UmVmIiwiZ2V0VGFyZ2V0UmVmIiwiaGFuZGxlRW50ZXIiLCJvbk9wZW5Db21wbGV0ZSIsImhhbmRsZUV4aXRlZCIsImNzcyIsInN0eWxlIiwib25lT2YiLCJUT1AiLCJUT1BfTEVGVCIsIlRPUF9SSUdIVCIsIkJPVFRPTSIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiTEVGVCIsIlJJR0hUIiwiaXNSZXF1aXJlZCIsImJvb2wiLCJmdW5jIiwibnVtYmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLFVBQVAsTUFBdUIsbUNBQXZCO0FBQ0EsU0FBU0MsTUFBVCxRQUF1QixjQUF2QjtBQUNBLFNBQVNDLEtBQVQsUUFBc0IsYUFBdEI7QUFDQSxTQUFTQyxhQUFULEVBQXdCQyxRQUF4QixRQUF3QyxpQkFBeEM7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLGVBQXhCO0FBRUEsSUFBTUMsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxNQUFNO0FBRGdCLENBQXhCOztBQUlBLElBQU1DLFlBQVksR0FBRyxTQUFmQSxZQUFlO0FBQUEsU0FBTztBQUMxQkMsSUFBQUEsR0FBRyxFQUFFLElBRHFCO0FBRTFCQyxJQUFBQSxJQUFJLEVBQUUsSUFGb0I7QUFHMUJDLElBQUFBLGVBQWUsRUFBRTtBQUhTLEdBQVA7QUFBQSxDQUFyQjs7QUFNQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUztBQUFBLE1BQUdDLFlBQUgsUUFBR0EsWUFBSDtBQUFBLE1BQWlCQyxpQkFBakIsUUFBaUJBLGlCQUFqQjtBQUFBLFNBQTBDO0FBQ3ZEQyxJQUFBQSxR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MEYsTUFBVixDQUFpQkgsVUFsQ1o7O0FBb0NqQjs7O0FBR0FoQyxFQUFBQSxZQUFZLEVBQUV2RCxTQUFTLENBQUMwRixNQUFWLENBQWlCSCxVQXZDZDs7QUF5Q2pCOzs7O0FBSUFwQixFQUFBQSxNQUFNLEVBQUVuRSxTQUFTLENBQUN5RixJQUFWLENBQWVGLFVBN0NOOztBQStDakI7OztBQUdBekUsRUFBQUEsWUFBWSxFQUFFZCxTQUFTLENBQUMwRixNQUFWLENBQWlCSCxVQWxEZDs7QUFvRGpCOzs7QUFHQXhFLEVBQUFBLGlCQUFpQixFQUFFZixTQUFTLENBQUMwRixNQUFWLENBQWlCSCxVQXZEbkI7O0FBeURqQjs7O0FBR0F2QixFQUFBQSxlQUFlLEVBQUVoRSxTQUFTLENBQUN5RixJQUFWLENBQWVGLFVBNURmOztBQThEakI7OztBQUdBYixFQUFBQSxjQUFjLEVBQUUxRSxTQUFTLENBQUN5RixJQUFWLENBQWVGO0FBakVkLEM7O2dCQURBaEUsVSxrQkFxRUc7QUFDcEJQLEVBQUFBLFFBQVEsRUFBRVgsUUFBUSxDQUFDNkUsTUFEQztBQUVwQnZCLEVBQUFBLFVBQVUsRUFBRSxDQUZRO0FBR3BCSixFQUFBQSxZQUFZLEVBQUUsQ0FITTtBQUlwQnpDLEVBQUFBLFlBQVksRUFBRSxHQUpNO0FBS3BCQyxFQUFBQSxpQkFBaUIsRUFBRSxHQUxDO0FBTXBCYyxFQUFBQSxRQUFRLEVBQUUsb0JBQU0sQ0FBRSxDQU5FO0FBT3BCNkMsRUFBQUEsY0FBYyxFQUFFLDBCQUFNLENBQUUsQ0FQSjtBQVFwQlYsRUFBQUEsZUFBZSxFQUFFLDJCQUFNLENBQUU7QUFSTCxDOztTQXJFSHpDLFUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uJ1xuaW1wb3J0IHsgUG9ydGFsIH0gZnJvbSAnLi4vLi4vcG9ydGFsJ1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICcuLi8uLi9zdGFjaydcbmltcG9ydCB7IFN0YWNraW5nT3JkZXIsIFBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJ1xuaW1wb3J0IGdldFBvc2l0aW9uIGZyb20gJy4vZ2V0UG9zaXRpb24nXG5cbmNvbnN0IGFuaW1hdGlvbkVhc2luZyA9IHtcbiAgc3ByaW5nOiBgY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMjAsIDEuMTc1KWBcbn1cblxuY29uc3QgaW5pdGlhbFN0YXRlID0gKCkgPT4gKHtcbiAgdG9wOiBudWxsLFxuICBsZWZ0OiBudWxsLFxuICB0cmFuc2Zvcm1PcmlnaW46IG51bGxcbn0pXG5cbmNvbnN0IGdldENTUyA9ICh7IGluaXRpYWxTY2FsZSwgYW5pbWF0aW9uRHVyYXRpb24gfSkgPT4gKHtcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIG9wYWNpdHk6IDAsXG4gIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogYW5pbWF0aW9uRWFzaW5nLnNwcmluZyxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHthbmltYXRpb25EdXJhdGlvbn1tc2AsXG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogJ29wYWNpdHksIHRyYW5zZm9ybScsXG4gIHRyYW5zZm9ybTogYHNjYWxlKCR7aW5pdGlhbFNjYWxlfSkgdHJhbnNsYXRlWSgtMXB4KWAsXG4gICcmW2RhdGEtc3RhdGU9XCJlbnRlcmluZ1wiXSwgJltkYXRhLXN0YXRlPVwiZW50ZXJlZFwiXSc6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJyxcbiAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgfSxcbiAgJyZbZGF0YS1zdGF0ZT1cImV4aXRpbmdcIl0nOiB7XG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25lciBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHBvc2l0aW9uZWQgaXMgb24uXG4gICAgICogU21hcnQgcG9zaXRpb25pbmcgbWlnaHQgb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAgIFBvc2l0aW9uLlRPUCxcbiAgICAgIFBvc2l0aW9uLlRPUF9MRUZULFxuICAgICAgUG9zaXRpb24uVE9QX1JJR0hULFxuICAgICAgUG9zaXRpb24uQk9UVE9NLFxuICAgICAgUG9zaXRpb24uQk9UVE9NX0xFRlQsXG4gICAgICBQb3NpdGlvbi5CT1RUT01fUklHSFQsXG4gICAgICBQb3NpdGlvbi5MRUZULFxuICAgICAgUG9zaXRpb24uUklHSFRcbiAgICBdKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBzaG93IHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAgICovXG4gICAgaXNTaG93bjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICAgKi9cbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVmIG9mIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAgICovXG4gICAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSBib2R5IHRvIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAgICovXG4gICAgYm9keU9mZnNldDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gZGlzdGFuY2UgZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAgICovXG4gICAgdGFyZ2V0T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSBub2RlIGZvciB0aGUgdGFyZ2V0LlxuICAgICAqICh7IGdldFJlZjogKCkgLT4gUmVmLCBpc1Nob3duOiBCb29sIH0pIC0+IFJlYWN0IE5vZGVcbiAgICAgKi9cbiAgICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHNjYWxlIG9mIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAgICovXG4gICAgaW5pdGlhbFNjYWxlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV4aXQgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBvbkNsb3NlQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGVudGVyIHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25PcGVuQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgcG9zaXRpb246IFBvc2l0aW9uLkJPVFRPTSxcbiAgICBib2R5T2Zmc2V0OiA2LFxuICAgIHRhcmdldE9mZnNldDogNixcbiAgICBpbml0aWFsU2NhbGU6IDAuOSxcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMzAwLFxuICAgIGlubmVyUmVmOiAoKSA9PiB7fSxcbiAgICBvbk9wZW5Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgb25DbG9zZUNvbXBsZXRlOiAoKSA9PiB7fVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dClcbiAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlKClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLmxhdGVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxhdGVzdEFuaW1hdGlvbkZyYW1lKVxuICAgIH1cbiAgfVxuXG4gIGdldFRhcmdldFJlZiA9IHJlZiA9PiB7XG4gICAgdGhpcy50YXJnZXRSZWYgPSByZWZcbiAgfVxuXG4gIGdldFJlZiA9IHJlZiA9PiB7XG4gICAgdGhpcy5wb3NpdGlvbmVyUmVmID0gcmVmXG4gICAgdGhpcy5wcm9wcy5pbm5lclJlZihyZWYpXG4gIH1cblxuICBoYW5kbGVFbnRlciA9ICgpID0+IHtcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cblxuICB1cGRhdGUgPSAocHJldkhlaWdodCA9IDAsIHByZXZXaWR0aCA9IDApID0+IHtcbiAgICBpZiAoIXRoaXMucHJvcHMuaXNTaG93biB8fCAhdGhpcy50YXJnZXRSZWYgfHwgIXRoaXMucG9zaXRpb25lclJlZikgcmV0dXJuXG5cbiAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGhpcy50YXJnZXRSZWYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBoYXNFbnRlcmVkID1cbiAgICAgIHRoaXMucG9zaXRpb25lclJlZi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnKSA9PT0gJ2VudGVyZWQnXG5cbiAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgd2luZG93LnNjcm9sbFlcbiAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICsgd2luZG93LnNjcm9sbFhcblxuICAgIGxldCBoZWlnaHRcbiAgICBsZXQgd2lkdGhcbiAgICBpZiAoaGFzRW50ZXJlZCkge1xuICAgICAgLy8gT25seSB3aGVuIHRoZSBhbmltYXRpb24gaXMgZG9uZSBzaG91bGQgd2Ugb3B0LWluIHRvIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgXG4gICAgICBjb25zdCBwb3NpdGlvbmVyUmVjdCA9IHRoaXMucG9zaXRpb25lclJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2VnbWVudGlvL2V2ZXJncmVlbi9pc3N1ZXMvMjU1XG4gICAgICAvLyBXZSBuZWVkIHRvIGNlaWwgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gcHJldmVudCBqaXR0ZXIgd2hlblxuICAgICAgLy8gdGhlIHdpbmRvdyBpcyB6b29tZWQgKHdoZW4gYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCBpcyBub3QgYW4gaW50ZWdlcilcbiAgICAgIGhlaWdodCA9IE1hdGgucm91bmQocG9zaXRpb25lclJlY3QuaGVpZ2h0KVxuICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHBvc2l0aW9uZXJSZWN0LndpZHRoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIHRoZSBhbmltYXRpb24gaXMgaW4gZmxpZ2h0IHVzZSBgb2Zmc2V0V2lkdGgvSGVpZ2h0YCB3aGljaFxuICAgICAgLy8gZG9lcyBub3QgY2FsY3VsYXRlIHRoZSBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBhcyBwYXJ0IG9mIGl0cyByZXN1bHQuXG4gICAgICAvLyBUaGVyZSBpcyBzdGlsbCBjaGFuZ2Ugb24gaml0dGVyIGR1cmluZyB0aGUgYW5pbWF0aW9uIChhbHRob3VnaCB1bm90aWNhYmxlKVxuICAgICAgLy8gV2hlbiB0aGUgYnJvd3NlciBpcyB6b29tZWQgaW4g4oCUIHdlIGZpeCB0aGlzIHdpdGggYE1hdGgubWF4YC5cbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KHRoaXMucG9zaXRpb25lclJlZi5vZmZzZXRIZWlnaHQsIHByZXZIZWlnaHQpXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHRoaXMucG9zaXRpb25lclJlZi5vZmZzZXRXaWR0aCwgcHJldldpZHRoKVxuICAgIH1cblxuICAgIGNvbnN0IHsgcmVjdCwgdHJhbnNmb3JtT3JpZ2luIH0gPSBnZXRQb3NpdGlvbih7XG4gICAgICBwb3NpdGlvbjogdGhpcy5wcm9wcy5wb3NpdGlvbixcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXQ6IHRoaXMucHJvcHMudGFyZ2V0T2Zmc2V0LFxuICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgd2lkdGg6IHZpZXdwb3J0V2lkdGgsXG4gICAgICAgIGhlaWdodDogdmlld3BvcnRIZWlnaHRcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydE9mZnNldDogdGhpcy5wcm9wcy5ib2R5T2Zmc2V0XG4gICAgfSlcblxuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luXG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLmxhdGVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZShoZWlnaHQsIHdpZHRoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIGhhbmRsZUV4aXRlZCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmluaXRpYWxTdGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25DbG9zZUNvbXBsZXRlKClcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgaXNTaG93bixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaW5pdGlhbFNjYWxlLFxuICAgICAgdGFyZ2V0T2Zmc2V0LFxuICAgICAgYW5pbWF0aW9uRHVyYXRpb25cbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3QgeyBsZWZ0LCB0b3AsIHRyYW5zZm9ybU9yaWdpbiB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdGFjayB2YWx1ZT17U3RhY2tpbmdPcmRlci5QT1NJVElPTkVSfT5cbiAgICAgICAge3pJbmRleCA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICAge3RhcmdldCh7IGdldFJlZjogdGhpcy5nZXRUYXJnZXRSZWYsIGlzU2hvd24gfSl9XG5cbiAgICAgICAgICAgICAgPFRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBpbj17aXNTaG93bn1cbiAgICAgICAgICAgICAgICB0aW1lb3V0PXthbmltYXRpb25EdXJhdGlvbn1cbiAgICAgICAgICAgICAgICBvbkVudGVyPXt0aGlzLmhhbmRsZUVudGVyfVxuICAgICAgICAgICAgICAgIG9uRW50ZXJlZD17dGhpcy5wcm9wcy5vbk9wZW5Db21wbGV0ZX1cbiAgICAgICAgICAgICAgICBvbkV4aXRlZD17dGhpcy5oYW5kbGVFeGl0ZWR9XG4gICAgICAgICAgICAgICAgdW5tb3VudE9uRXhpdFxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3N0YXRlID0+IChcbiAgICAgICAgICAgICAgICAgIDxQb3J0YWw+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIGNzczogZ2V0Q1NTKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIGdldFJlZjogdGhpcy5nZXRSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICA8L1BvcnRhbD5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L1RyYW5zaXRpb24+XG4gICAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgIDwvU3RhY2s+XG4gICAgKVxuICB9XG59XG4iXX0=